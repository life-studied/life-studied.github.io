<!DOCTYPE html>
<html lang="zh-cmn-Hans">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>06 网络2 | Yunyin&#39;s blog</title>
  
    <link rel="icon" href="/assert/C++.jpg">
  
  
  
  <!--link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css"-->
  
<link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css">

  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
<div class="Shell">
    <aside class='SideBar'>
    <section class='avatar' style="background-image: url(/assets/background.jpg)">
        <div class='av-pic' style="background-image: url(/assets/C++.jpg)">
        </div>
    </section>
    <section class='menu'>
        <div>Yunyin&#39;s blog</div>
        
        <ul>
          
            <a href="/" class="Btn">
              <li>Home</li>
            </a>  
          
            <a href="/archives/" class="Btn">
              <li>Archive</li>
            </a>  
          
            <a href="/tags/" class="Btn">
              <li>Tags</li>
            </a>  
          
            <a href="/categories/" class="Btn">
              <li>Categories</li>
            </a>  
          
        </ul>
    </section>
    <section class="media">
        
    </section>
</aside>

    <div class="container">
        <div data-pager-shell>
            <div>
  <article class='ContentView'>
    <header class='PageTitle'>
        <h1>06 网络2</h1>
    </header>

    <section>
      <h1>06 网络2</h1>
<p>参考资料：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/os/8_network_system/selete_poll_epoll.html#%E6%9C%80%E5%9F%BA%E6%9C%AC%E7%9A%84-socket-%E6%A8%A1%E5%9E%8B">9.2 I/O 多路复用：select/poll/epoll | 小林coding (xiaolincoding.com)</a></p>
<span id="more"></span>
<h2 id="select">select</h2>
<p>​	<code>select</code> 允许程序同时监视多个文件描述符（通常是套接字描述符），以确定是否有任何文件描述符准备好读取、写入或有错误。它是一种在单个线程中处理多个 I/O 操作的机制。</p>
<h3 id="函数原型">函数原型</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">select</span><span class="params">(<span class="type">int</span> nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="参数">参数</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>nfds</code>: 需要监视的最大文件描述符加1。例如，如果你监视的最大文件描述符是 5，则 <code>nfds</code> 应该是 6。</p>
</li>
<li class="lvl-2">
<p><code>readfds</code>: 指向一个集合，包含需要监视读取状态的文件描述符。</p>
</li>
<li class="lvl-2">
<p><code>writefds</code>: 指向一个集合，包含需要监视写入状态的文件描述符。</p>
</li>
<li class="lvl-2">
<p><code>exceptfds</code>: 指向一个集合，包含需要监视异常条件的文件描述符。</p>
</li>
<li class="lvl-2">
<p><code>timeout</code>: 指向一个 <code>timeval</code> 结构，指定 <code>select</code> 调用的超时时间。如果为 NULL，则 <code>select</code> 会一直阻塞直到有文件描述符准备好。</p>
</li>
</ul>
<h4 id="返回值">返回值</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>成功时，返回准备好的文件描述符的数量。</p>
</li>
<li class="lvl-2">
<p>错误时，返回-1。</p>
</li>
</ul>
<h3 id="fd-set-结构体"><code>fd_set</code> 结构体</h3>
<p><code>fd_set</code> 是一个用于 <code>select</code> 函数的特定数据结构，它能够存储一组非负的文件描述符（通常是套接字）。这个结构体在 <code>&lt;sys/select.h&gt;</code> 头文件中定义，但它的具体实现是依赖于平台的。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>FD_ZERO(fd_set *set)</code>: 这个宏将 <code>fd_set</code> 初始化为空集合，即没有任何文件描述符。</p>
</li>
<li class="lvl-2">
<p><code>FD_SET(int fd, fd_set *set)</code>: 这个宏将文件描述符 <code>fd</code> 添加到 <code>fd_set</code> 集合中。</p>
</li>
<li class="lvl-2">
<p><code>FD_CLR(int fd, fd_set *set)</code>: 这个宏从 <code>fd_set</code> 集合中移除文件描述符 <code>fd</code>。</p>
</li>
<li class="lvl-2">
<p><code>FD_ISSET(int fd, fd_set *set)</code>: 这个宏检查文件描述符 <code>fd</code> 是否在 <code>fd_set</code> 集合中。</p>
</li>
</ul>
<h3 id="struct-timeval-结构体"><code>struct timeval</code> 结构体</h3>
<p><code>timeval</code> 结构体用于指定时间间隔，它在 <code>&lt;sys/time.h&gt;</code> 头文件中定义。<code>select</code> 函数使用它来设置操作的超时时间。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>struct timeval &#123;   long tv_sec;    // 秒   long tv_usec;   // 微秒 &#125;;</code></p>
</li>
</ul>
<h3 id="服务器示例">服务器示例</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 12345</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_CLIENTS 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="type">bool</span>&gt; <span class="title function_">running</span><span class="params">(<span class="literal">true</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程安全的打印</span></span><br><span class="line"><span class="built_in">std</span>::mutex cout_mutex;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread_safe_print</span><span class="params">(<span class="type">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;msg)</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title function_">lock</span><span class="params">(cout_mutex)</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; msg &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理客户端连接的函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">handle_client</span><span class="params">(<span class="type">int</span> client_socket, <span class="built_in">std</span>::atomic&lt;<span class="type">bool</span>&gt; &amp;running, fd_set &amp;readfds)</span> &#123;</span><br><span class="line">    <span class="type">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">    <span class="type">ssize_t</span> bytes_read;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (running &amp;&amp; (bytes_read = read(client_socket, buffer, BUFFER_SIZE)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        buffer[bytes_read] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 确保字符串以空字符结尾</span></span><br><span class="line">        thread_safe_print(<span class="string">&quot;Received: &quot;</span> + <span class="built_in">std</span>::<span class="built_in">string</span>(buffer));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送响应</span></span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *response = buffer;</span><br><span class="line">        <span class="keyword">if</span> (write(client_socket, response, <span class="built_in">strlen</span>(response)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            thread_safe_print(<span class="string">&quot;Failed to write to socket: &quot;</span> + <span class="built_in">std</span>::to_string(errno));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当没有更多数据可读时，关闭套接字并从 readfds 中移除</span></span><br><span class="line">    close(client_socket);</span><br><span class="line">    FD_CLR(client_socket, &amp;readfds);</span><br><span class="line">    thread_safe_print(<span class="string">&quot;Closing client socket&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> server_fd, client_fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>, <span class="title">client_addr</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> client_len = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; clients;</span><br><span class="line">    fd_set readfds;</span><br><span class="line">    <span class="type">int</span> max_fd = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建套接字</span></span><br><span class="line">    <span class="keyword">if</span> ((server_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket creation failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化服务器地址结构</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    server_addr.sin_port = htons(PORT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定套接字</span></span><br><span class="line">    <span class="keyword">if</span> (bind(server_fd, (<span class="keyword">struct</span> sockaddr *)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    <span class="keyword">if</span> (listen(server_fd, MAX_CLIENTS) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    thread_safe_print(<span class="string">&quot;Server is listening on port &quot;</span> + <span class="built_in">std</span>::to_string(PORT));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 server_fd 添加到 readfds 并设置 max_fd</span></span><br><span class="line">    FD_ZERO(&amp;readfds);</span><br><span class="line">    FD_SET(server_fd, &amp;readfds);</span><br><span class="line">    max_fd = server_fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (running) &#123;</span><br><span class="line">        <span class="comment">// 复制 readfds 以便 select 可以修改它</span></span><br><span class="line">        fd_set temp_fds = readfds;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置超时时间</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">timeout</span>;</span></span><br><span class="line">        timeout.tv_sec = <span class="number">5</span>;</span><br><span class="line">        timeout.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用 select</span></span><br><span class="line">        <span class="type">int</span> activity = select(max_fd + <span class="number">1</span>, &amp;temp_fds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;timeout);</span><br><span class="line">        <span class="keyword">if</span> (activity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno != EINTR) &#123;</span><br><span class="line">                perror(<span class="string">&quot;select error&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (activity == <span class="number">0</span>) &#123;</span><br><span class="line">            thread_safe_print(<span class="string">&quot;No activity detected, continuing to listen...&quot;</span>);</span><br><span class="line">            using namespace <span class="built_in">std</span>::literals;</span><br><span class="line">            <span class="built_in">std</span>::this_thread::sleep_for(<span class="number">100</span>ms);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查 server_fd 是否准备好接受新连接</span></span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(server_fd, &amp;temp_fds)) &#123;</span><br><span class="line">            client_fd = accept(server_fd, (<span class="keyword">struct</span> sockaddr *)&amp;client_addr, &amp;client_len);</span><br><span class="line">            <span class="keyword">if</span> (client_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                perror(<span class="string">&quot;accept failed&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            clients.push_back(client_fd); <span class="comment">// 添加到客户端列表</span></span><br><span class="line">            FD_SET(client_fd, &amp;readfds);  <span class="comment">// 添加到监视集合</span></span><br><span class="line">            <span class="keyword">if</span> (client_fd &gt; max_fd) &#123;</span><br><span class="line">                max_fd = client_fd; <span class="comment">// 更新最大文件描述符</span></span><br><span class="line">            &#125;</span><br><span class="line">            thread_safe_print(<span class="string">&quot;New client connected&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查所有客户端套接字</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; clients.size(); ++i) &#123;</span><br><span class="line">            client_fd = clients[i];</span><br><span class="line">            <span class="keyword">if</span> (FD_ISSET(client_fd, &amp;temp_fds)) &#123;</span><br><span class="line">                <span class="comment">// 处理每个就绪的客户端套接字</span></span><br><span class="line">                handle_client(client_fd, running, readfds);</span><br><span class="line">                <span class="comment">// handle_client 函数可能会关闭套接字并从 readfds 中移除</span></span><br><span class="line">                <span class="comment">// 因此我们需要从 clients 列表中删除它</span></span><br><span class="line">                clients.erase(clients.begin() + i);</span><br><span class="line">                --i; <span class="comment">// 调整索引以跳过新元素</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理和关闭</span></span><br><span class="line">    close(server_fd);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> client_fd : clients) &#123;</span><br><span class="line">        close(client_fd);</span><br><span class="line">    &#125;</span><br><span class="line">    running = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="poll">poll</h2>
<p><code>poll</code> 是一种比 <code>select</code> 更灵活的 I/O 多路复用技术，它允许程序同时监视多个文件描述符，以确定是否有任何文件描述符准备好进行读取、写入或出现错误。与 <code>select</code> 不同，<code>poll</code> 没有最大文件描述符数量的限制，并且可以监视更多的事件类型。</p>
<h3 id="函数原型-2">函数原型</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="参数-2">参数</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>fds</code>: 指向一个 <code>pollfd</code> 结构体数组，每个结构体代表一个要监视的文件描述符。</p>
</li>
<li class="lvl-2">
<p><code>nfds</code>: 数组中的结构体数量。</p>
</li>
<li class="lvl-2">
<p><code>timeout</code>: 指定 <code>poll</code> 调用的超时时间（毫秒）。如果为 -1，则 <code>poll</code> 会一直阻塞直到有文件描述符准备好。</p>
</li>
</ul>
<h4 id="返回值-2">返回值</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>成功时，返回准备好的文件描述符的数量。</p>
</li>
<li class="lvl-2">
<p>错误时，返回 -1。</p>
</li>
</ul>
<h3 id="struct-pollfd-结构体"><code>struct pollfd</code> 结构体</h3>
<p><code>pollfd</code> 结构体用于 <code>poll</code> 函数，它定义了要监视的文件描述符和相关的事件。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">pollfd</span> &#123;</span><br><span class="line">    <span class="type">int</span>   fd;         <span class="comment">// 文件描述符</span></span><br><span class="line">    <span class="type">short</span> events;     <span class="comment">// 需要监视的事件</span></span><br><span class="line">    <span class="type">short</span> revents;    <span class="comment">// 发生事件的结果</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>events</code> 字段可以是以下宏的组合：</p>
<ul class="lvl-2">
<li class="lvl-4"><code>POLLIN</code>: 文件描述符可读。</li>
<li class="lvl-4"><code>POLLOUT</code>: 文件描述符可写。</li>
<li class="lvl-4"><code>POLLERR</code>: 出现错误。</li>
<li class="lvl-4"><code>POLLHUP</code>: 对端关闭连接。</li>
</ul>
</li>
<li class="lvl-2">
<p><code>revents</code> 字段在 <code>poll</code> 返回后，会设置为以下宏的组合之一：</p>
<ul class="lvl-2">
<li class="lvl-4"><code>POLLIN</code>: 有数据可读。</li>
<li class="lvl-4"><code>POLLOUT</code>: 可以写入数据。</li>
<li class="lvl-4"><code>POLLERR</code>: 检测到错误。</li>
<li class="lvl-4"><code>POLLHUP</code>: 对端关闭连接。</li>
</ul>
</li>
</ul>
<h3 id="服务器示例-2">服务器示例</h3>
<p>以下是一个使用 <code>poll</code> 的简单 echo 服务器示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 12345</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_CLIENTS 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">handle_client</span><span class="params">(<span class="keyword">struct</span> pollfd&amp; pfd)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">        <span class="type">ssize_t</span> bytes_read = read(pfd.fd, buffer, BUFFER_SIZE);</span><br><span class="line">        <span class="keyword">if</span> (bytes_read &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            buffer[bytes_read] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Received: &quot;</span> &lt;&lt; buffer &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="comment">// 发送响应</span></span><br><span class="line">            <span class="keyword">if</span> (write(pfd.fd, buffer, bytes_read) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                perror(<span class="string">&quot;write failed&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (bytes_read &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Client disconnected&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            close(pfd.fd);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> server_fd, client_fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>, <span class="title">client_addr</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> client_len = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span>&gt;</span> pollfds;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建套接字</span></span><br><span class="line">    server_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (server_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket creation failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化服务器地址结构</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    server_addr.sin_port = htons(PORT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定套接字</span></span><br><span class="line">    <span class="keyword">if</span> (bind(server_fd, (<span class="keyword">struct</span> sockaddr *)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    <span class="keyword">if</span> (listen(server_fd, MAX_CLIENTS) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Server is listening on port &quot;</span> &lt;&lt; PORT &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 pollfd 结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pfd</span>;</span></span><br><span class="line">    pfd.fd = server_fd;</span><br><span class="line">    pfd.events = POLLIN;</span><br><span class="line">    pollfds.push_back(pfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">int</span> activity = poll(pollfds.data(), pollfds.size(), <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (activity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;poll failed&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (activity == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;No activity detected, continuing to listen...&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查 server_fd 是否准备好接受新连接</span></span><br><span class="line">        <span class="keyword">if</span> (pollfds[<span class="number">0</span>].revents &amp; POLLIN) &#123;</span><br><span class="line">            client_fd = accept(server_fd, (<span class="keyword">struct</span> sockaddr *)&amp;client_addr, &amp;client_len);</span><br><span class="line">            <span class="keyword">if</span> (client_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                perror(<span class="string">&quot;accept failed&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加新客户端到 pollfds</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pfd_client</span>;</span></span><br><span class="line">            pfd_client.fd = client_fd;</span><br><span class="line">            pfd_client.events = POLLIN;</span><br><span class="line">            pollfds.push_back(pfd_client);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;New client connected&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查所有客户端套接字</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; i &lt; pollfds.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pollfds[i].revents &amp; POLLIN) &#123;</span><br><span class="line">                handle_client(pollfds[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pollfds[i].revents &amp; POLLHUP) &#123;</span><br><span class="line">                <span class="comment">// 对端关闭了连接</span></span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Client disconnected&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                close(pollfds[i].fd);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pollfds[i].revents &amp; POLLERR) &#123;</span><br><span class="line">                <span class="comment">// 检测到错误，例如网络故障</span></span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Error detected on client socket&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                close(pollfds[i].fd);</span><br><span class="line">            &#125;</span><br><span class="line">            pollfds.erase(pollfds.begin() + i);</span><br><span class="line">            --i; <span class="comment">// 调整索引以跳过新元素</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理和关闭</span></span><br><span class="line">    close(server_fd);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;pfd : pollfds) &#123;</span><br><span class="line">        close(pfd.fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="epoll">epoll</h2>
<p>了解您的需求，我会给出一个完整的 <code>epoll</code> 示例，包括每个函数的原型、参数说明、返回值，以及一个完整的服务器示例代码。</p>
<h3 id="epoll-create">epoll_create</h3>
<h4 id="函数原型-3">函数原型</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_create</span><span class="params">(<span class="type">int</span> size)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="参数说明">参数说明</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>size</code>: 指定了epoll实例所能同时监控的文件描述符的数量。这个参数并不是限制最大并发数量，而是一个提示给内核的初始大小。</p>
</li>
</ul>
<h4 id="返回值-3">返回值</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>成功时，返回一个新的 epoll 实例的文件描述符。</p>
</li>
<li class="lvl-2">
<p>错误时，返回 -1，并设置 <code>errno</code> 以指示错误。</p>
</li>
</ul>
<h3 id="epoll-create1">epoll_create1</h3>
<h4 id="函数原型-4">函数原型</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_create1</span><span class="params">(<span class="type">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="参数说明-2">参数说明</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>flags</code>: 可以是以下标志的组合：</p>
<ul class="lvl-2">
<li class="lvl-4"><code>EPOLL_CLOEXEC</code>: 设置 <code>close-on-exec</code> 属性。</li>
<li class="lvl-4"><code>0</code>：无特殊行为</li>
</ul>
</li>
</ul>
<h4 id="返回值-4">返回值</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>成功时，返回一个新的 epoll 实例的文件描述符。</p>
</li>
<li class="lvl-2">
<p>错误时，返回 -1，并设置 <code>errno</code> 以指示错误。</p>
</li>
</ul>
<h3 id="epoll-ctl">epoll_ctl</h3>
<h4 id="函数原型-5">函数原型</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="参数说明-3">参数说明</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>epfd</code>: epoll 实例的文件描述符。</p>
</li>
<li class="lvl-2">
<p><code>op</code>: 操作类型，可以是 <code>EPOLL_CTL_ADD</code>（添加）、<code>EPOLL_CTL_MOD</code>（修改）或 <code>EPOLL_CTL_DEL</code>（删除）。</p>
</li>
<li class="lvl-2">
<p><code>fd</code>: 要操作的文件描述符。</p>
</li>
<li class="lvl-2">
<p><code>event</code>: 指向 <code>epoll_event</code> 结构体的指针，包含了要设置的事件和用户数据。</p>
</li>
</ul>
<h4 id="返回值-5">返回值</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>成功时，返回 0。</p>
</li>
<li class="lvl-2">
<p>错误时，返回 -1，并设置 <code>errno</code> 以指示错误。</p>
</li>
</ul>
<h3 id="epoll-wait">epoll_wait</h3>
<h4 id="函数原型-6">函数原型</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="参数说明-4">参数说明</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>epfd</code>: epoll 实例的文件描述符。</p>
</li>
<li class="lvl-2">
<p><code>events</code>: 指向 <code>epoll_event</code> 结构体数组的指针，用于接收发生的事件。</p>
</li>
<li class="lvl-2">
<p><code>maxevents</code>: <code>events</code> 数组的最大容量。</p>
</li>
<li class="lvl-2">
<p><code>timeout</code>: 等待时间，单位为毫秒。-1 表示无限期等待。</p>
</li>
</ul>
<h4 id="返回值-6">返回值</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>成功时，返回数组中已填充的事件数量。</p>
</li>
<li class="lvl-2">
<p>错误时，返回 -1，并设置 <code>errno</code> 以指示错误。</p>
</li>
</ul>
<h3 id="epoll-event-结构体">epoll_event 结构体</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_event</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> events;    <span class="comment">// 要监视的事件类型</span></span><br><span class="line">    <span class="type">epoll_data_t</span> data;  <span class="comment">// 用户自定义数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="epoll-服务器示例">epoll 服务器示例</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 12345</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_CONN 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_BUF 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> server_fd, epoll_fd, client_fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>, <span class="title">client_addr</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> client_len = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line">    <span class="type">char</span> buffer[MAX_BUF];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建套接字</span></span><br><span class="line">    server_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (server_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket creation failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化服务器地址结构</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    server_addr.sin_port = htons(PORT);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 绑定套接字</span></span><br><span class="line">    <span class="keyword">if</span> (bind(server_fd, (<span class="keyword">struct</span> sockaddr *)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    <span class="keyword">if</span> (listen(server_fd, MAX_CONN) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Server is listening on port &quot;</span> &lt;&lt; PORT &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化 epoll 实例</span></span><br><span class="line">    epoll_fd = epoll_create1(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (epoll_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll_create1 failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 server_fd 添加到 epoll 监视列表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">    ev.events = EPOLLIN;</span><br><span class="line">    ev.data.fd = server_fd;</span><br><span class="line">    <span class="keyword">if</span> (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, server_fd, &amp;ev) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll_ctl failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[<span class="title">MAX_CONN</span>];</span></span><br><span class="line">        <span class="type">int</span> n = epoll_wait(epoll_fd, events, MAX_CONN, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;epoll_wait failed&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (events[i].data.fd == server_fd) &#123;</span><br><span class="line">                <span class="comment">// 接受新的连接</span></span><br><span class="line">                client_fd = accept(server_fd, (<span class="keyword">struct</span> sockaddr *)&amp;client_addr, &amp;client_len);</span><br><span class="line">                <span class="keyword">if</span> (client_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;accept failed&quot;</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;New client connected&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 添加新的 client_fd 到 epoll</span></span><br><span class="line">                ev.events = EPOLLIN;</span><br><span class="line">                ev.data.fd = client_fd;</span><br><span class="line">                <span class="keyword">if</span> (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, client_fd, &amp;ev) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;epoll_ctl failed&quot;</span>);</span><br><span class="line">                    close(client_fd);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 读取数据</span></span><br><span class="line">                <span class="type">int</span> socket_fd = events[i].data.fd;</span><br><span class="line">                <span class="type">int</span> nbytes = read(socket_fd, buffer, MAX_BUF);</span><br><span class="line">                <span class="keyword">if</span> (nbytes &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;read failed&quot;</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nbytes == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 客户端关闭连接</span></span><br><span class="line">                    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Client disconnected&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                    close(socket_fd);</span><br><span class="line">                    epoll_ctl(epoll_fd, EPOLL_CTL_DEL, socket_fd, nullptr);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 回显读取的数据</span></span><br><span class="line">                    buffer[nbytes] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Read Message:&quot;</span> &lt;&lt; buffer &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                    write(socket_fd, buffer, nbytes);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理资源</span></span><br><span class="line">    close(server_fd);</span><br><span class="line">    close(epoll_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="练习">练习</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>file server 用epoll改写一下</p>
</li>
</ul>


      

    </section>
    
      <section class='ArticleMeta'>
          <div>
            发布于&nbsp;
            <time datetime="2024-11-15T16:00:00.000Z" itemprop="datePublished">
              2024-11-16
            </time>
          </div>
          
      </section>
    
    
      <section>
        <div id="disqus_thread"></div>
        <script>
          window.disqus_config = function () {
            this.page.url = window.location.toString()
            this.page.identifier = window.location.pathname
          }
          if (typeof DISQUS === 'undefined') {
            (function() { // DON'T EDIT BELOW THIS LINE
              var d = document, s = d.createElement('script');
              s.src = 'https://YunyinBlog.disqus.com/embed.js';
              s.setAttribute('data-timestamp', +new Date());
              (d.head || d.body).appendChild(s);
            })();
          } else {
            DISQUS.reset({
                reload: true,
                config: window.disqus_config
            })
          }
        </script>
      </section>
    
</article>

  
</div>

            <footer>
    <div>© 2024 - Yunyin </div>
    <div>
        <span>
            Powered by <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a>
        </span>
        ,
        <span>
            Theme - <a target="_blank" rel="noopener" href="https://github.com/nameoverflow/hexo-theme-icalm">Icalm</a>
        </span>
    </div>
</footer>

        </div>
    </div>
</div>

<script src="/js/pager/dist/singlepager.js"></script>

<script>
var sp = new Pager('data-pager-shell')

</script>
</body>
</html>